<div dir="rtl" align="right">

<h2>بخش سوم: حملات پیشرفته Active Directory - تحلیل، تشخیص و کاهش</h2>

<p>Active Directory به عنوان یک سرویس دایرکتوری حیاتی برای مدیریت منابع شبکه در شبکه‌های مبتنی بر ویندوز عمل می‌کند. این سرویس امکان متمرکزسازی مدیریت منابع مختلف شبکه از جمله حساب‌های کاربری و کامپیوتری، منابع و سیاست‌های امنیتی را فراهم می‌کند. AD بر روی یک ساختار سلسله‌مراتبی متشکل از دامنه‌ها در سطح بالا و اشیاء مختلف تو در تو مانند کاربران، کامپیوترها و گروه‌ها عمل می‌کند. این ساختار برای ارائه یک روش سازمان‌یافته و کارآمد برای مدیریت منابع شبکه طراحی شده است و اطمینان حاصل می‌کند که سیاست‌های امنیتی به طور یکنواخت در سراسر شبکه اعمال می‌شوند.</p>
<p>Active Directory از پروتکل Lightweight Directory Access Protocol (LDAP) برای ارتباط بین دامنه‌ها و کنترلرهای دامنه استفاده می‌کند. LDAP یک پروتکل سرویس دایرکتوری است که امکان مدیریت سرویس‌های دایرکتوری توزیع شده را از طریق یک شبکه IP فراهم می‌کند. علاوه بر این، AD از Kerberos، یک پروتکل احراز هویت امن برای احراز هویت از طریق شبکه استفاده می‌کند. این امر تضمین می‌کند که تنها کاربران و کامپیوترهای مجاز می‌توانند به منابع شبکه دسترسی داشته باشند و در نتیجه امنیت شبکه را افزایش می‌دهد.</p>
<p>با این حال، Active Directory در برابر حملات مصون نیست و حملات به AD می‌توانند عواقب فاجعه‌باری برای شبکه داشته باشند. حملات موفق Active Directory از سه مرحله اصلی تشکیل شده‌اند: کشف (Discovery)، افزایش سطح دسترسی از طریق سرقت اعتبارنامه‌های حساب معتبر (Privilege Escalation) و دستیابی به دسترسی به کامپیوترهای دیگر در شبکه/دامنه (Lateral Movement). هنگامی که مهاجمان جایگاهی در شبکه هدف به دست می‌آورند، بلافاصله تمرکز خود را به دستیابی به دسترسی افزایش یافته به سیستم‌های اضافی که به آن‌ها کمک می‌کند هدف نهایی خود را محقق کنند، مانند رمزگذاری و سرقت داده‌های سازمانی، معطوف می‌کنند.</p>

<h3>استفاده از روش‌های احراز هویت جایگزین (T1550)</h3>

<p>مهاجمان می‌توانند با استفاده از مواد احراز هویت جایگزین مانند هش‌های رمز عبور، تیکت‌های Kerberos و توکن‌های دسترسی برنامه، کنترل‌های دسترسی عادی را دور بزنند. این تکنیک که به عنوان T1550 در چارچوب MITRE ATT&CK شناخته می‌شود، مهاجمان را قادر می‌سازد تا به صورت جانبی در یک محیط حرکت کنند و دسترسی غیرمجاز به دست آورند. دو زیرتکنیک اصلی این روش عبارتند از Pass-the-Hash (T1550.002) و Pass-the-Ticket (T1550.003).</p>

<h4>Pass-the-Hash (PtH) - T1550.002</h4>

<p>Pass-the-Hash یک حمله مبتنی بر هویت است که توسط مهاجمان برای دستیابی به دسترسی به سیستم‌ها و امتیازات اضافی در یک شبکه پس از نفوذ اولیه به سیستم استفاده می‌شود. در یک سناریوی معمولی Pass-the-Hash، مهاجمان ابتدا دسترسی اولیه به یک شبکه هدف به دست می‌آورند، سپس اعتبارنامه‌های کاربری هش شده را سرقت یا dump می‌کنند و در نهایت از اعتبارنامه‌های dump شده برای ایجاد یک نشست کاربری جدید بر روی میزبان در معرض خطر استفاده می‌کنند.</p>
<p>برخلاف سایر حملات، حملات Pass-the-Hash نوع منحصر به فردی از سرقت اعتبارنامه را نشان می‌دهند که در آن مهاجم از پروتکل احراز هویت Windows New Technology LAN Manager (NTLM) برای احراز هویت به یک سیستم راه دور با استفاده از هش از پیش محاسبه شده رمز عبور یک کاربر معتبر استفاده می‌کند. هنگامی که یک کاربر به یک سیستم ویندوز که به پروتکل NTLM متکی است وارد می‌شود، سیستم یک هش NTLM از رمز عبور کاربر بدون استفاده از تکنیکی به نام salting که امنیت رمزهای عبور هش شده ذخیره شده در سرورها و کنترلرهای دامنه را افزایش می‌دهد، تولید می‌کند.</p>
<p>NTLM یک روش single sign-on است که از یک سیستم چالش-پاسخ برای تأیید هویت کاربر بدون نیاز به رمز عبور کاربر استفاده می‌کند. بنابراین، این تکنیک حمله نیازی به استفاده از ابزارهای شخص ثالث برای crack کردن ندارد، زیرا نسخه متن ساده رمز عبور مورد نیاز نیست و در نتیجه نیاز به انجام عملیات زمان‌بر crack کردن را از بین می‌برد. اگر مهاجم هش NTLM رمز عبور یک کاربر را از طریق روش‌هایی مانند استخراج آن از حافظه <code>lsass.exe</code> یا از فایل <code>%systemroot%\system32\config\SAM</code>، گرفتن آن در طول انتقالات شبکه یا dump کردن آن از یک نسخه پشتیبان یا تصویر یک سیستم به دست آورد، می‌تواند با passing the hash به یک سیستم راه دور که حساب کاربری در معرض خطر را تشخیص می‌دهد، از رمز عبور هش شده استفاده کند.</p>
<p>مهم است که توجه داشته باشید این یک آسیب‌پذیری نیست، بلکه یک انتخاب طراحی عمدی با هدف کاهش اصطکاک و بهبود تجربه کلی کاربر است. مهاجمان اغلب از ابزارهای مختلفی مانند <b>Mimikatz</b>، <b>evil-winrm</b> و cmdlet های داخلی PowerShell برای اجرای حملات Pass-the-Hash استفاده می‌کنند.</p>

<p><b>استفاده از Mimikatz برای Pass-the-Hash:</b></p>
<p>استفاده از Mimikatz برای حمله Pass-the-Hash از سه مرحله اصلی تشکیل شده است. در مرحله اول، مهاجمان با استفاده از ماژول sekurlsa در Mimikatz، لیستی از کاربران اخیراً وارد شده و اعتبارنامه‌های سیستم‌عامل آن‌ها را dump می‌کنند. تابع logonpasswords این ماژول به طور خاص داده‌های نشست ورود مانند هش‌های رمز عبور ذخیره شده و اعتبارنامه‌های کش شده را استخراج می‌کند. توجه داشته باشید که قبل از استفاده از دستور <code>sekurlsa::logonpasswords</code>، مهاجمان باید دستور <code>privilege::debug</code> را اجرا کنند تا Mimikatz بتواند به درستی اجرا شود. به طور پیش‌فرض، LSASS با یکپارچگی بالا اجرا می‌شود و از debug شدن توسط فرآیندهای غیرمجاز محافظت می‌شود. با این حال، با فعال کردن امتیاز debugger، مهاجم می‌تواند این حفاظت را دور بزند و به حافظه LSASS دسترسی پیدا کند تا داده‌های نشست ورود را استخراج کند.</p>
<p>در مرحله دوم، مهاجم با استفاده از دستور <code>sekurlsa::pth</code> در Mimikatz، هش را pass می‌کند تا کاربر را جعل کند و به سیستم راه دور دسترسی پیدا کند. این دستور یک ویژگی است که حملات Pass-the-Hash را تسهیل می‌کند. این تکنیک به مهاجم اجازه می‌دهد تا با استفاده از یک هش NTLM گرفته شده از رمز عبور یک کاربر، به یک سیستم راه دور احراز هویت کند، بدون نیاز به رمز عبور واقعی. برای اجرای این دستور، مهاجم باید پارامترهای زیر را ارائه دهد: <code>/user</code> (نام کاربری)، <code>/domain</code> (نام دامنه) و <code>/ntlm</code> (هش NTLM رمز عبور کاربر). در مرحله سوم، مهاجم از حساب کاربری جدید به دست آمده برای گسترش دسترسی شبکه خود استفاده می‌کند. به عنوان مثال، مهاجم می‌تواند از یک ابزار خط فرمان به نام PsExec برای اجرای کد از راه دور بر روی میزبان دیگری استفاده کند.</p>

<p><b>استفاده از PowerShell برای Pass-the-Hash:</b></p>
<p>معمول است که مهاجمان از cmdlet Invoke-WMIExec که امکان اجرای دستورات دلخواه بر روی یک ماشین ویندوز راه دور با استفاده از WMI (Windows Management Instrumentation) را فراهم می‌کند، برای انجام یک حمله PtH استفاده کنند. توجه داشته باشید که Invoke-WMIExec یک cmdlet داخلی PowerShell است که در بسیاری از سیستم‌های ویندوز اخیر وجود دارد. این ویژگی امکان اجرای دستورات دلخواه بر روی یک ماشین ویندوز راه دور از طریق Windows Management Instrumentation (WMI) را فراهم می‌کند. بودن یک cmdlet داخلی، حمله با استفاده از Invoke-WMIExec را مخفی‌تر می‌کند، زیرا نیازی به دانلود یا نصب اضافی ندارد.</p>

<p><b>استفاده از evil-winrm برای Pass-the-Hash:</b></p>
<p>ابزار evil-winrm یک Ruby gem است که امکان اجرای دستورات راه دور بر روی یک ماشین ویندوز با استفاده از پروتکل Windows Remote Management (WinRM) را فراهم می‌کند. از آنجایی که evil-winrm یک ابزار داخلی نیست، مهاجمان باید قبل از استفاده آن را نصب کنند. در یک حمله Pass-the-Hash با استفاده از evil-winrm، مهاجم نام کاربری، هش NTLM و آدرس IP سیستم هدف را به عنوان پارامتر در دستور evil-winrm مشخص می‌کند.</p>

<p><b>روش‌های تشخیص حمله Pass-the-Hash:</b></p>
<p>برای تشخیص یک حمله احتمالی Pass-the-Hash، Event ID های شناخته شده زیر باید مورد نظارت قرار گیرند:</p>
<p><b>Event ID 1 (Sysmon) - Process Create</b>: فیلدهای کلیدی شامل LogonId، ParentProcessId، ParentImage، CurrentDirectory، CommandLine، IntegrityLevel، ParentCommandLine، UtcTime، ProcessId، User، Hashes و Image هستند. این رویداد می‌تواند اجرای ابزارهایی مانند Mimikatz، PsExec یا evil-winrm را نشان دهد.</p>
<p><b>Event ID 5 (Sysmon) - Process Terminated</b>: فیلدهای کلیدی شامل UtcTime، ProcessId و Image هستند که می‌توانند پایان فرآیندهای مشکوک را نشان دهند.</p>
<p><b>Event ID 10 (Sysmon) - Process Accessed</b>: فیلدهای کلیدی شامل SourceThreadId، TargetProcessId، GrantedAccess، SourceImage و TargetImage هستند. این رویداد بسیار مهم است زیرا می‌تواند دسترسی به فرآیند <code>lsass.exe</code> را نشان دهد که یک نشانه واضح از تلاش برای dump کردن اعتبارنامه‌ها است.</p>
<p><b>Event ID 4624 (Security) - An Account Was Successfully Logged On</b>: فیلدهای کلیدی شامل Account Name، Account Domain و Logon ID هستند. Logon Type 3 (Network) یا Logon Type 9 (NewCredentials) می‌توانند نشانه‌ای از یک حمله Pass-the-Hash باشند.</p>
<p><b>Event ID 4672 (Security) - Special Privileges Assigned to New Logon</b>: فیلدهای کلیدی شامل Security ID، Account Name و Account Domain هستند که نشان می‌دهند یک ورود با امتیازات خاص انجام شده است.</p>
<p><b>Event ID 4688 (Security) - A New Process Has Been Created</b>: فیلدهای کلیدی شامل Account Domain، Source Process Name، New Process Name، Token Escalation Type، New Process ID و Source Process ID هستند.</p>

<p><b>تکنیک‌های کاهش حمله Pass-the-Hash:</b></p>
<p>برای کاهش خطر حملات Pass-the-Hash، سازمان‌ها می‌توانند چندین اقدام فنی را اعمال کنند. یکی از این اقدامات فعال کردن Windows Defender Credential Guard است، یک ویژگی که در ویندوز 10 و Windows Server 2016 معرفی شد. این ابزار از virtualization برای ایمن‌سازی ذخیره‌سازی اعتبارنامه و محدود کردن دسترسی تنها به فرآیندهای قابل اعتماد استفاده می‌کند. اقدام دیگر لغو امتیازات مدیریتی از ایستگاه‌های کاری کاربر است که توانایی مهاجم برای اجرای بدافزار و استخراج هش‌ها از <code>LSASS.exe</code> را محدود می‌کند. همچنین، محدود کردن تعداد نقاط پایانی که کاربران بر روی آن‌ها امتیازات مدیریتی دارند و اجتناب از امتیازات مدیریتی در سراسر مرزهای امنیتی، خطر استفاده از یک اعتبارنامه در معرض خطر برای افزایش امتیازات را کاهش می‌دهد.</p>
<p>تصادفی کردن و ذخیره رمزهای عبور مدیر محلی با یک راه‌حل مانند Microsoft's Local Administrator Password Solution (LAPS) نیز یک لایه امنیتی اضافی اضافه می‌کند، زیرا توانایی مهاجم برای حرکت جانبی با حساب‌های محلی که رمز عبور یکسانی دارند را کاهش می‌دهد. همچنین توصیه می‌شود از احراز هویت حساب‌های محلی از طریق شبکه جلوگیری شود که می‌تواند از طریق استفاده از SID های شناخته شده در سیاست‌های گروهی به دست آید.</p>

<h4>Pass-the-Ticket (PtT) - T1550.003</h4>

<p>Pass-the-Ticket یک تکنیک است که به مهاجم اجازه می‌دهد از یک Kerberos Ticket Granting Ticket که قبلاً به دست آورده استفاده کند. TGT یک جزء حیاتی از پروتکل Kerberos است، زیرا به کاربر اجازه می‌دهد بدون نیاز به وارد کردن رمز عبور خود هر بار، به سیستم‌های متعدد احراز هویت کند.</p>
<p>Ticket Granting Ticket (TGT) نوعی تیکت است که توسط Domain Controller (DC) به یک کاربر پس از احراز هویت موفق به دامنه صادر می‌شود. این تیکت شامل اطلاعات حیاتی مانند کلید نشست کاربر، عضویت گروه و امتیازات است که برای درخواست تیکت‌های سرویس برای سرویس‌های خاص بر روی سیستم‌های هدف استفاده می‌شوند. Kerberos با استفاده از هش رمز عبور کاربر، TGT را رمزگذاری می‌کند و از الگوریتم‌های رمزگذاری متقارن (مانند DES یا AES) بسته به پیکربندی محیط Kerberos استفاده می‌کند. پس از رمزگذاری، TGT به کامپیوتر کاربر ارسال می‌شود و در حافظه ذخیره می‌شود.</p>
<p>هنگامی که کاربر می‌خواهد به یک منبع در سیستم دیگری دسترسی پیدا کند، از TGT برای درخواست یک تیکت سرویس از DC استفاده می‌کند. تیکت سرویس نیز با کلید نشست کاربر رمزگذاری می‌شود و حاوی یک کلید نشست رمزگذاری شده است که می‌تواند برای احراز هویت به سیستم هدف استفاده شود. سپس تیکت سرویس به کامپیوتر کاربر ارسال می‌شود، جایی که برای احراز هویت به سیستم هدف استفاده می‌شود.</p>
<p>با داشتن یک کلید TGT سرقت شده، مهاجم می‌تواند یک تیکت سرویس را از DC برای یک سرویس خاص بر روی یک سیستم هدف درخواست کند تا به منابع آن دسترسی پیدا کند. مهاجمان اغلب از ابزارهای مختلفی مانند <b>Mimikatz</b>، <b>Kekeo</b>، <b>Rubeus</b> و <b>Creddump7</b> برای اجرای حملات Pass-the-Ticket استفاده می‌کنند.</p>

<p><b>استفاده از Mimikatz برای Pass-the-Ticket:</b></p>
<p>استفاده از Mimikatz برای حمله PtT از چهار مرحله اصلی تشکیل شده است. در مرحله اول، مهاجم می‌تواند از دستور <code>sekurlsa::tickets</code> در Mimikatz با پارامتر <code>/export</code> برای استخراج تمام تیکت‌های Kerberos از حافظه و ذخیره آن‌ها به عنوان فایل‌های <code>.kirbi</code> استفاده کند. با بررسی نام‌های فایل‌های <code>.kirbi</code>، می‌توان تعیین کرد که آیا تیکت‌های Kerberos برای یک مدیر دامنه وجود دارد یا خیر.</p>
<p>در مرحله دوم، مهاجم از دستور <code>kerberos::ptt</code> در Mimikatz برای درج TGT به دست آمده به نشست خود استفاده می‌کند که در نتیجه نشست آن‌ها هویت و مجوزهای TGT سرقت شده را برای دسترسی آینده به منابع بدون دانستن اعتبارنامه‌های متن ساده به خود می‌گیرد. مهم است که ذکر شود TGT عمر محدودی دارد و پس از یک دوره زمانی خاص منقضی می‌شود. کاربر باید برای به دست آوردن یک TGT جدید، دوباره به دامنه احراز هویت کند.</p>
<p>در مرحله سوم، پس از آماده شدن تیکت به دست آمده برای استفاده مجدد، مهاجم باید قابلیت‌های آن را شناسایی کند، یعنی اینکه کجا می‌تواند استفاده شود. یک TGS فقط می‌تواند دسترسی به منبع خاصی که برای آن صادر شده است را فراهم کند و مهاجم می‌تواند با بررسی TGS، آن اطلاعات را پیدا کند. برای استفاده از یک TGT، مهاجم ممکن است مجبور باشد یک مرحله کشف داخلی را برای کشف دسترسی که ارائه می‌دهد انجام دهد. این می‌تواند به سادگی بررسی عضویت‌های گروهی کاربر و جستجوی علائم واضح باشد.</p>
<p>در مرحله چهارم، مهاجم می‌تواند با استفاده از تیکت جعلی به منابع یکپارچه شده با Kerberos دسترسی پیدا کند و به اهداف خود ادامه دهد.</p>

<p><b>روش‌های تشخیص حمله Pass-the-Ticket:</b></p>
<p>Event ID های مشابه با Pass-the-Hash برای تشخیص Pass-the-Ticket استفاده می‌شوند، با تمرکز ویژه بر Event ID 4768 (A Kerberos Authentication Ticket (TGT) Was Requested) و Event ID 4769 (A Kerberos Service Ticket Was Requested). همچنین، Sysmon Event ID 10 می‌تواند دسترسی به فرآیند <code>lsass.exe</code> برای استخراج تیکت‌ها را نشان دهد.</p>

<h3>Kerberoasting - T1558.003</h3>

<p>Kerberoasting یک تکنیک است که برای به دست آوردن هش‌های رمز عبور برای حساب‌های کاربری Active Directory (AD) که دارای مقادیر servicePrincipalName (SPN) هستند، استفاده می‌شود. در محیط‌های AD، SPN ها به حساب‌های کاربری یا کامپیوتری ثبت می‌شوند که به عنوان "حساب‌های سرویس" شناخته می‌شوند. این حساب‌ها برای اجرای سرویس‌ها و برنامه‌ها استفاده می‌شوند و معمولاً کمترین امتیاز لازم برای انجام وظیفه خود را دارند.</p>
<p>در مورد Kerberoasting، مهاجم می‌تواند از مقدار SPN یک حساب سرویس برای درخواست یک تیکت سرویس (TGS) سوء استفاده کند. تیکت TGS ممکن است (از طریق RC4) با هش رمز عبور حساب سرویس اختصاص داده شده به SPN درخواستی به عنوان کلید رمزگذاری شود. این بدان معناست که مهاجمی که تیکت‌های TGS را در ترافیک شبکه ضبط می‌کند یا آن‌ها را از حافظه استخراج می‌کند، می‌تواند هش رمز عبور حساب سرویس را استخراج کند و یک حمله brute force آفلاین برای بازیابی رمز عبور متن ساده انجام دهد.</p>
<p>مهم است که توجه داشته باشید Kerberoasting و حملات Pass-the-Ticket دو تکنیک متفاوت هستند که برای سرقت یا جعل اعتبارنامه‌های معتبر در یک محیط Kerberos استفاده می‌شوند. Kerberoasting یک روش برای به دست آوردن اعتبارنامه‌های حساب سرویس با درخواست تیکت‌های سرویس از یک کنترلر دامنه و crack کردن آن‌ها به صورت آفلاین است. از طرف دیگر، Pass-the-Ticket تکنیکی است که در آن مهاجم یک تیکت Kerberos ticket-granting (TGT) را از نشست کاربر می‌دزدد و از آن برای جعل کاربر برای دسترسی به منابع شبکه استفاده می‌کند.</p>

<p><b>ابزارها و تکنیک‌های انجام Kerberoasting:</b></p>
<p>برای این حمله، نه تنها یک ابزار استفاده می‌شود، بلکه همکاری آن‌ها مانند Mimikatz، Rubeus، Impacket، John the Ripper و Hashcat مورد نیاز است.</p>

<p><b>استفاده از Impacket برای Kerberoasting:</b></p>
<p>حمله Kerberoasting با استفاده از اسکریپت Impacket از سه بخش اصلی تشکیل شده است. در مرحله اول، شناسایی SPN ها و درخواست TGS ها انجام می‌شود. اسکریپت GetUserSPNs (Python) از Impacket می‌تواند تمام مراحل لازم برای درخواست یک ST برای یک سرویس با توجه به SPN آن و اعتبارنامه‌های معتبر دامنه را انجام دهد.</p>
<p>در مرحله دوم، با داشتن رمزهای عبور سرقت شده در فایل <code>kerberoastables.txt</code>، مهاجم می‌تواند یک حمله brute force آفلاین برای به دست آوردن رمز عبور متن ساده با استفاده از ابزارهای شخص ثالث مانند John the Ripper و Hashcat انجام دهد. در مرحله سوم، پس از crack شدن رمز عبور، مهاجم می‌تواند از اعتبارنامه‌های حساب سرویس برای دسترسی به منابع شبکه و ادامه اهداف خود استفاده کند.</p>

<p><b>استفاده از Rubeus برای Kerberoasting:</b></p>
<p>حمله Kerberoasting که از Rubeus استفاده می‌کند از چهار بخش اصلی تشکیل شده است. در مرحله اول، شمارش servicePrincipalNames انجام می‌شود. مهاجمان می‌توانند فیلترهای LDAP سفارشی را برای جستجوی کاربران با مقادیر SPN ثبت شده برای دامنه فعلی توسعه دهند. در مرحله دوم، مهاجم می‌تواند با شناسایی و شمارش Service Principal Names (SPNs) حساب‌های سرویس خاص را هدف قرار دهد و سپس تیکت‌های Ticket Granting Service (TGS) را برای این حساب‌های سرویس درخواست کند. ابزارهایی مانند Rubeus می‌توانند برای خودکارسازی این فرآیند با استخراج هش‌های رمز عبور از حافظه استفاده شوند.</p>
<p>در مرحله سوم، مرحله بعدی در حمله به دست آوردن رمزهای عبور متن ساده حساب‌های سرویس است که این فرآیند با استفاده از یک حمله brute-force آفلاین انجام می‌شود، به این معنی که مهاجم نیازی به برقراری ارتباط با Active Directory ندارد و این امر آن را غیرقابل تشخیص می‌کند. برای انجام این کار، مهاجم می‌تواند از ابزارهای مختلفی مانند John the Ripper و Hashcat که به طور خاص برای crack کردن رمز عبور با دیکشنری‌های رمزهای عبور رایج طراحی شده‌اند، استفاده کند. در مرحله چهارم، پس از crack شدن رمز عبور، مهاجم می‌تواند از اعتبارنامه‌های حساب سرویس برای دسترسی به منابع شبکه و ادامه اهداف خود استفاده کند.</p>

<p><b>روش‌های تشخیص Kerberoasting:</b></p>
<p>برای تشخیص فعالیت احتمالی Kerberoasting، Event ID 4769 (A Kerberos Service Ticket Was Requested) باید مورد نظارت قرار گیرد. فیلدهای کلیدی شامل Account Name، Service Name، Client Address، Ticket Options و Ticket Encryption Type هستند. درخواست‌های TGS غیرمعمول، به ویژه آن‌هایی که از نوع رمزگذاری RC4 (0x17) استفاده می‌کنند در حالی که سیستم از AES پشتیبانی می‌کند، می‌توانند نشانه‌ای از Kerberoasting باشند.</p>
<p>همچنین، Event ID 4768 (A Kerberos Authentication Ticket (TGT) Was Requested) و Event ID 4770 (A Kerberos Service Ticket Was Renewed) می‌توانند اطلاعات مفیدی فراهم کنند. یک تکنیک دفاعی مؤثر ایجاد Honey SPN ها است - SPN های فریبنده که با هیچ استفاده مشروعی ایجاد نشده‌اند و به طور خاص برای جذب بازیگران مخرب طراحی شده‌اند. هرگونه درخواست برای این SPN ها یک نشانه واضح از یک حمله Kerberoasting است.</p>

<p><b>تکنیک‌های کاهش Kerberoasting:</b></p>
<p>برای محافظت در برابر حملات Kerberoasting، توصیه می‌شود اقداماتی برای محدود کردن دسترسی مهاجمان و دشوارتر کردن به دست آوردن هش‌های رمز عبور حساب‌های سرویس انجام شود. استفاده از رمزهای عبور قوی و پیچیده برای حساب‌های سرویس (حداقل 25 کاراکتر با ترکیبی از حروف بزرگ، حروف کوچک، اعداد و نمادها) می‌تواند crack کردن آفلاین را بسیار دشوارتر کند. استفاده از Group Managed Service Accounts (gMSA) که رمزهای عبور پیچیده و طولانی را به طور خودکار مدیریت و تغییر می‌دهند، یک راه‌حل مؤثر است. فعال کردن AES encryption برای Kerberos به جای RC4 نیز امنیت را افزایش می‌دهد. نظارت منظم بر Event ID 4769 برای درخواست‌های TGS غیرمعمول و پیاده‌سازی Honey SPN ها برای تشخیص زودهنگام حملات نیز توصیه می‌شود.</p>

<h3>Golden Ticket Attack - T1558.001</h3>

<p>حمله Golden Ticket شامل جعل یک تیکت Kerberos برای دستیابی به دسترسی غیرمجاز به یک سیستم کامپیوتری به عنوان یک کاربر ممتاز است. برای انجام این حمله، مهاجم باید NTHash حساب krbtgt، حسابی که مسئول رمزگذاری و امضای تمام تیکت‌ها در یک دامنه است، و همچنین Security Identifier (SID) دامنه را به دست آورد. با این اطلاعات، مهاجم می‌تواند یک تیکت طلایی جعلی ایجاد کند که یک تیکت مشروع صادر شده توسط سرور احراز هویت دامنه را تقلید می‌کند. این تیکت طلایی به مهاجم توانایی دسترسی به اطلاعات و منابع حساس در سیستم هدف را می‌دهد.</p>
<p>حمله Golden Ticket یکی از خطرناک‌ترین حملات در محیط‌های Active Directory است زیرا به مهاجم اجازه می‌دهد تا دسترسی نامحدود به تمام کامپیوترها و سرورهای سازمان، از جمله Domain Controllers (DC) داشته باشد. یک Golden Ticket یک دعوت‌نامه باز برای مهاجمان برای دسترسی به تمام منابع است. Golden Ticket یک Kerberos Ticket-Granting Ticket (TGT) جعلی است که مهاجمان را قادر می‌سازد تیکت‌های Ticket Granting Service (TGS) را برای هر حسابی در Active Directory تولید کنند و دسترسی نامحدود به منابع هدف به دست آورند.</p>

<p><b>نحوه کار حمله Golden Ticket:</b></p>
<p>قبل از تحلیل و مطالعه playbook مهاجم، مهم است که درک کنیم چگونه مهاجم می‌تواند از یک Golden Ticket برای درخواست تیکت‌های ticket-granting service (TGS) استفاده کند و دسترسی نامحدود به منابع خاص را فعال کند. مهاجم می‌تواند با اعتبارنامه‌های کاربری در معرض خطر به یک کامپیوتر متصل به دامنه وارد شود و فرآیند ارتباط Kerberos را هدف قرار دهد.</p>
<p>فرآیند احراز هویت Kerberos به شرح زیر است: سیستم رمز عبور کاربر را به یک هش NTLM تبدیل می‌کند، یک timestamp را با هش رمزگذاری می‌کند و آن را به Key Distribution Center (KDC) به عنوان یک authenticator در درخواست تیکت احراز هویت (TGT) ارسال می‌کند. Domain Controller (KDC) اطلاعات کاربر مانند محدودیت‌های ورود، عضویت گروه و غیره را بررسی می‌کند و یک TGT ایجاد می‌کند. TGT ایجاد شده با یک حساب خاص در DC که به عنوان سرویس Kerberos (KRBTGT) شناخته می‌شود، رمزگذاری و امضا می‌شود. تنها KRBTGT در دامنه می‌تواند داده‌های TGT را باز کند و بخواند. DC، TGT را اعطا می‌کند و آن را به کاربر تحویل می‌دهد.</p>
<p>کاربر TGT را ارائه می‌دهد و یک تیکت Ticket Granting Service (TGS) را درخواست می‌کند. DC، TGT ارائه شده را اعتبارسنجی می‌کند و تیکت TGS را ایجاد می‌کند. DC، TGS را با استفاده از هش رمز عبور NTLM حساب سرویس هدف رمزگذاری می‌کند و آن را به کاربر ارسال می‌کند. کاربر به سرور برنامه میزبان سرویس در پورت مناسب متصل می‌شود و TGS را ارائه می‌دهد. سرویس با استفاده از هش رمز عبور NTLM خود تیکت TGS را باز می‌کند.</p>

<p><b>ابزارها و تکنیک‌های انجام حمله Golden Ticket:</b></p>
<p>مهاجمان می‌توانند از ابزارهای شخص ثالث متعددی مانند <b>Mimikatz</b> و <b>Impacket</b> برای انجام یک حمله Golden Ticket استفاده کنند.</p>

<p><b>استفاده از Impacket برای Golden Ticket:</b></p>
<p>در این سناریو، فرض می‌کنیم که پس از انجام یک حمله Kerberoasting، مهاجم یک فایل از هش‌ها را dump کرده و آن‌ها را crack کرده تا دسترسی مدیر به Domain Controller به دست آورد. به عبارت دیگر، ما رمز عبور متن ساده یک کاربر مدیر که می‌تواند به DC دسترسی داشته باشد را داریم.</p>
<p>یک حمله معمولی Golden Ticket با Impacket از دو بخش اصلی تشکیل شده است. در مرحله اول، جعل یک تیکت طلایی انجام می‌شود. برای ایجاد یک تیکت طلایی معتبر، اطلاعات خاصی مورد نیاز است، مانند NTHash حساب krbtgt کنترلر دامنه و SID دامنه. این اطلاعات را می‌توان با استفاده از اسکریپت <code>secretsdump.py</code> از Impacket به دست آورد، به شرطی که مهاجم دسترسی مدیر به کنترلر دامنه داشته باشد.</p>
<p>همچنین، مهاجم باید SID دامنه را بیاموزد. برای این کار، می‌توانند از ابزار <code>lookupsid.py</code> Impacket استفاده کنند. در نهایت، مهاجم از ابزار <code>ticketer.py</code> Impacket برای جعل یک تیکت طلایی برای یک کاربر دامنه استفاده می‌کند. یک مزیت <code>ticketer.py</code> این است که تیکت جعلی به یک فایل <code>.ccache</code> به جای <code>.kirbi</code> نوشته می‌شود؛ به عبارت دیگر، مهاجم مجبور نیست آن را تبدیل کند.</p>
<p>در مرحله دوم، استفاده از تیکت طلایی انجام می‌شود. برای راه‌اندازی تیکت طلایی برای استفاده، متغیر محیطی KRB5CCNAME باید به مسیر فایل <code>.ccache</code> تنظیم شود که می‌تواند یک مسیر فایل مطلق یا نسبی باشد. متغیر محیطی KRB5CCNAME برای اطلاع دادن به ابزارهای Impacket که از تیکت‌های Kerberos پشتیبانی می‌کنند که تیکت را کجا پیدا کنند، استفاده می‌شود. این به مهاجم اجازه می‌دهد از تیکت طلایی برای دسترسی به سیستم به عنوان یک کاربر ممتاز استفاده کند.</p>
<p>سپس، مهاجم می‌تواند از ابزارهای اجرای دستور Impacket، مانند <code>psexec.py</code>، <code>smbexec.py</code> یا <code>wmiexec.py</code> برای بارگذاری و احراز هویت با تیکت استفاده کند که در نهایت به مهاجم اجرای دستور می‌دهد. برای کار کردن احراز هویت Kerberos، مهاجم باید آدرس IP هدف، آدرس IP Domain Controller و نام دامنه را ارائه دهد.</p>

<p><b>استفاده از Mimikatz برای Golden Ticket:</b></p>
<p>یک حمله معمولی Golden Ticket با Mimikatz از سه بخش اصلی تشکیل شده است. در مرحله اول، به خطر انداختن هش رمز عبور برای حساب krbtgt انجام می‌شود. همانطور که در سناریوی Impacket بود، برای کار کردن یک حمله Golden Ticket، مهاجم باید دسترسی مدیر به یک Domain Controller داشته باشد. برای استخراج هش رمز عبور کاربر krbtgt، مهاجم می‌تواند از دستور <code>lsadump::dcsync</code> استفاده کند.</p>
<p>دستور <code>lsadump::dcsync /user:DOMAIN\KRBTGT</code> یک آرگومان خط فرمان برای Mimikatz است که به آن می‌گوید یک عملیات DCSync را با استفاده از حساب کاربری DOMAIN\KRBTGT انجام دهد، که حساب پیش‌فرض استفاده شده توسط سرویس احراز هویت Kerberos در محیط‌های Windows Active Directory است.</p>
<p>در مرحله دوم، جعل تیکت‌های Kerberos انجام می‌شود. پس از به دست آوردن دسترسی به هش رمز عبور KRBTGT، آن‌ها می‌توانند از Mimikatz برای جعل تیکت‌های Kerberos استفاده کنند. این می‌تواند شامل ایجاد یک ticket-granting ticket (TGT) جعلی برای یک حساب کاربری غیرموجود باشد. توجه داشته باشید که به‌روزرسانی‌های امنیتی در نوامبر 2021 برای Kerberos این روش حمله را patch کرده‌اند. در نتیجه، اگر کنترلرهای دامنه به‌روزرسانی را نصب کرده باشند، باید از یک حساب کاربری واقعی استفاده شود.</p>
<p>برای جعل یک TGT، مهاجم باید اطلاعات خاصی را به تابع <code>kerberos::golden</code> Mimikatz ارائه دهد: نام دامنه کاملاً واجد شرایط دامنه، شناسه امنیتی دامنه (SID)، هش رمز عبور کاربر KRBTGT (با استفاده از AES-256، و به طور جایگزین AES-128، NTLM یا RC4)، نام کاربری برای جعل، RID گروه‌ها برای گنجاندن در تیکت با اولین مورد که گروه اصلی کاربر است، و پرچم ptt برای نشان دادن اینکه آیا تیکت جعلی باید به نشست فعلی تزریق شود به جای ذخیره آن در یک فایل.</p>
<p>در مرحله سوم، استفاده از تیکت Kerberos جعلی انجام می‌شود. مهاجم می‌تواند از تیکت جعلی برای دستیابی به دسترسی به منابع یکپارچه شده با Kerberos استفاده کند. TGT با هش رمز عبور واقعی KRBTGT امضا و رمزگذاری شده است، که آن را به یک اثبات هویت معتبر در چشم هر کنترلر دامنه تبدیل می‌کند. سپس کنترلر دامنه تیکت‌های ticket-granting service (TGS) را بر اساس TGT صادر می‌کند.</p>
<p>همانطور که مهاجم اطلاعات بیشتری در مورد محیط به دست می‌آورد، می‌تواند از تیکت‌های جعلی برای دسترسی به برنامه‌ها، پایگاه‌های داده یا سایر منابعی که از Active Directory برای احراز هویت و مجوز استفاده می‌کنند، استفاده کند. مهاجم ممکن است گروه‌های خاصی را با گنجاندن RID آن‌ها در فرآیند جعل تیکت هدف قرار دهد.</p>

<p><b>روش‌های تشخیص حمله Golden Ticket:</b></p>
<p>تشخیص حملات Golden Ticket چالش‌برانگیز است زیرا تیکت‌های جعلی از نظر فنی معتبر هستند و توسط هش واقعی KRBTGT امضا شده‌اند. با این حال، چندین نشانه می‌تواند به تشخیص این حملات کمک کند:</p>
<p><b>Event ID 4769 (Security) - A Kerberos Service Ticket Was Requested</b>: فیلدهای کلیدی شامل Account Name، Service Name و Client Address هستند. یک نشانه مهم، درخواست‌های TGS بدون یک TGT request قبلی (Event ID 4768) است. همچنین، تیکت‌هایی با عمر غیرمعمول طولانی (مثلاً 10 سال) یا تیکت‌هایی که برای حساب‌های غیرموجود یا غیرفعال صادر شده‌اند، مشکوک هستند.</p>
<p><b>Event ID 4624 (Security) - An Account Was Successfully Logged On</b>: فیلدهای کلیدی شامل Account Name، Account Domain و Logon ID هستند. ورودهایی با Logon Type 3 (Network) که از حساب‌های غیرمعمول یا در زمان‌های غیرعادی انجام می‌شوند، باید بررسی شوند.</p>
<p><b>Event ID 4627 (Security) - Identifies the Account That Requested the Logon</b>: فیلدهای کلیدی شامل Security ID، Account Name، Account Domain و Logon ID هستند.</p>
<p>یکی از نکات مهم که در منابع اصلی به آن اشاره نشده بود، این است که راه‌حل‌هایی که می‌توانند الگوهای استفاده از Golden Ticket را شناسایی کنند، می‌توانند تشخیص حمله را تسریع کنند. هرچه زودتر بتوانید حملات احتمالی را تشخیص دهید، زودتر می‌توانید پاسخ دهید و خسارت را کاهش دهید. راه‌حل‌های پیشرفته مانند Microsoft Defender for Identity می‌توانند تیکت‌های جعلی را با تحلیل رفتاری و تشخیص ناهنجاری شناسایی کنند.</p>

<p><b>تکنیک‌های کاهش حمله Golden Ticket:</b></p>
<p>برای محافظت در برابر حملات Golden Ticket، توصیه می‌شود اقداماتی برای محدود کردن دسترسی مهاجمان و دشوارتر کردن به دست آوردن هش رمز عبور کاربر KRBTGT انجام شود. این اقدامات شامل موارد زیر است:</p>
<p><b>محدود کردن امتیازات مدیریتی در سراسر مرزهای امنیتی</b>: سازمان‌ها نباید به کاربران اجازه دهند امتیازات مدیریتی در سراسر مرزهای امنیتی داشته باشند. به عنوان مثال، مهاجمی که به یک ایستگاه کاری دسترسی پیدا می‌کند نباید بتواند امتیازات خود را برای هدف قرار دادن کنترلر دامنه افزایش دهد.</p>
<p><b>به حداقل رساندن امتیازات افزایش یافته</b>: حساب‌های سرویس با امتیازات بالا، مانند Domain Admins، باید تنها در صورت لزوم اعطا شوند. با محدود کردن تعداد این حساب‌ها، سازمان‌ها می‌توانند تعداد اهداف را برای مهاجمی که به دنبال هش KRBTGT است، کاهش دهند.</p>
<p><b>تغییر منظم رمز عبور برای حساب KRBTGT</b>: مهم است که رمز عبور کاربر KRBTGT را در یک برنامه منظم و بلافاصله پس از هرگونه تغییر در پرسنل مسئول مدیریت Active Directory تغییر دهید. رمز عبور باید دو بار، با فاصله 12-24 ساعت بین دو تغییر، تغییر داده شود تا از هرگونه اختلال سرویس جلوگیری شود. این به این دلیل است که تیکت‌های Kerberos می‌توانند تا 10 ساعت معتبر باشند، بنابراین تغییر یک بار رمز عبور ممکن است تیکت‌های جعلی موجود را باطل نکند.</p>
<p><b>پیاده‌سازی Privileged Access Workstations (PAWs)</b>: استفاده از ایستگاه‌های کاری اختصاصی برای وظایف مدیریتی که از سیستم‌های عادی کاربر جدا هستند، می‌تواند خطر سرقت اعتبارنامه‌های مدیریتی را کاهش دهد.</p>
<p><b>فعال کردن Advanced Audit Policies</b>: پیکربندی دقیق سیاست‌های ممیزی برای ثبت رویدادهای Kerberos و نظارت بر آن‌ها برای فعالیت‌های مشکوک ضروری است.</p>

<hr>

<h2>بخش سوم: شواهد اجرای برنامه - تحلیل جامع آرتیفکت‌های فورنزیک</h2>

<p>شناسایی برنامه‌هایی که بر روی یک سیستم اجرا شده‌اند، یکی از ارکان اساسی هر تحقیق فورنزیک دیجیتال است. سیستم‌عامل ویندوز، به دلایل مختلفی از جمله بهینه‌سازی عملکرد و سازگاری برنامه‌ها، مجموعه‌ای غنی از آرتیفکت‌ها را برای ردیابی اجرای برنامه‌ها ایجاد و نگهداری می‌کند. این شواهد به تحلیلگران کمک می‌کنند تا بدافزارهای اجرا شده، ابزارهای مورد استفاده توسط مهاجم، فعالیت‌های کاربران و timeline دقیق رویدادها را بازسازی کنند. در این بخش، به بررسی تفصیلی مهم‌ترین آرتیفکت‌های اجرای برنامه که در پوستر SANS FOR508 به آن‌ها اشاره شده، به همراه جزئیات فنی تکمیلی می‌پردازیم.</p>

<h3>UserAssist</h3>

<p><b>UserAssist</b> یک کلید رجیستری است که توسط Windows Explorer برای ردیابی برنامه‌هایی که به صورت تعاملی توسط کاربر از طریق رابط کاربری گرافیکی (GUI) اجرا شده‌اند، استفاده می‌شود. این کلید در <code>NTUSER.DAT\Software\Microsoft\Windows\CurrentVersion\Explorer\UserAssist</code> قرار دارد و برای هر کاربر به صورت جداگانه وجود دارد. UserAssist اطلاعات مفیدی مانند مسیر کامل برنامه، تعداد دفعات اجرا، آخرین زمان اجرا و مدت زمان اجرا (Focus Time) را ثبت می‌کند.</p>
<p>نکته جالب در مورد UserAssist این است که نام‌های برنامه‌ها با استفاده از الگوریتم ROT13 (یک رمزگذاری ساده جایگزینی) رمزگذاری شده‌اند. ROT13 هر حرف الفبا را با حرفی که 13 موقعیت جلوتر است جایگزین می‌کند. این رمزگذاری به راحتی قابل معکوس است و ابزارهای فورنزیک به طور خودکار آن را رمزگشایی می‌کنند. دلیل استفاده از ROT13 مشخص نیست، اما احتمالاً برای جلوگیری از خواندن تصادفی اطلاعات توسط کاربران معمولی است.</p>
<p>یکی از نکات مهم که در پوستر اصلی به آن اشاره نشده بود، این است که UserAssist تنها برنامه‌هایی را که از طریق رابط کاربری گرافیکی (مانند کلیک روی یک آیکون، استفاده از منوی استارت یا اجرای یک فایل از Explorer) اجرا شده‌اند را ثبت می‌کند. برنامه‌هایی که از طریق خط فرمان (Command Line) یا اسکریپت‌ها اجرا می‌شوند، در UserAssist ثبت نمی‌شوند. بنابراین، عدم وجود یک برنامه در UserAssist به معنای عدم اجرای آن نیست، بلکه ممکن است به معنای اجرای آن از طریق یک روش غیرتعاملی باشد.</p>
<p>UserAssist برای تحلیل فعالیت‌های کاربر بسیار مفید است و می‌تواند نشان دهد که کاربر چه برنامه‌هایی را اجرا کرده، چند بار آن‌ها را اجرا کرده و آخرین بار چه زمانی از آن‌ها استفاده کرده است. برای بدافزارهایی که از طریق رابط کاربری اجرا می‌شوند (مانند یک فایل اجرایی که کاربر دانلود کرده و روی آن دوبار کلیک کرده است)، UserAssist می‌تواند شواهد ارزشمندی فراهم کند. ابزارهایی مانند Registry Explorer و Eric Zimmerman's UserAssist Parser می‌توانند این داده‌ها را تجزیه و تحلیل کنند.</p>

<h3>Background Activity Moderator (BAM) و Desktop Activity Moderator (DAM)</h3>

<p><b>Background Activity Moderator (BAM)</b> و <b>Desktop Activity Moderator (DAM)</b> دو آرتیفکت نسبتاً جدید در ویندوز هستند که برای مدیریت فعالیت‌های پس‌زمینه و بهبود عمر باتری و کارایی سیستم معرفی شده‌اند. BAM در ویندوز 10 نسخه 1709 معرفی شد و هنوز در ویندوز 11 وجود دارد. DAM عملکرد مشابهی دارد اما بیشتر بر روی برنامه‌های دسکتاپ تمرکز دارد و عمدتاً در دستگاه‌هایی که از Modern Standby استفاده می‌کنند، یافت می‌شود.</p>
<p>این آرتیفکت‌ها در رجیستری در <code>SYSTEM\CurrentControlSet\Services\bam\UserSettings\{SID}</code> و <code>SYSTEM\CurrentControlSet\Services\dam\UserSettings\{SID}</code> ذخیره می‌شوند، جایی که {SID} شناسه امنیتی (Security Identifier) کاربر است. هر ورودی شامل مسیر کامل فایل اجرایی و یک timestamp 64-bit Windows FILETIME است که نشان‌دهنده آخرین زمان اجرای برنامه است.</p>
<p>یکی از ویژگی‌های مهم BAM/DAM این است که حتی اگر یک برنامه حذف شده باشد، رکورد آن در BAM/DAM تا 7 روز باقی می‌ماند (مگر اینکه سیستم reboot شود و فایل اجرایی دیگر وجود نداشته باشد). این ویژگی BAM/DAM را به یک آرتیفکت بسیار ارزشمند برای تحقیقات فورنزیک تبدیل می‌کند، زیرا می‌تواند شواهدی از بدافزارهایی که حذف شده‌اند را فراهم کند.</p>
<p>یکی از نکات مهم که در پوستر اصلی به آن اشاره نشده بود، این است که BAM/DAM برنامه‌هایی که از درایوهای USB یا شیرهای شبکه (Network Shares) اجرا می‌شوند را ثبت نمی‌کنند. تنها برنامه‌هایی که از درایوهای محلی (مانند C:\ یا D:\) اجرا می‌شوند، در BAM/DAM ثبت می‌شوند. همچنین، timestamp های BAM ممکن است چند دقیقه با زمان واقعی اجرای برنامه تفاوت داشته باشند، بنابراین بهتر است BAM/DAM را با سایر آرتیفکت‌ها مانند Prefetch، UserAssist و ShimCache برای ایجاد یک timeline دقیق‌تر ترکیب کرد.</p>
<p>BAM/DAM برای ردیابی فعالیت‌های اخیر کاربر و شناسایی برنامه‌های مشکوک بسیار مفید هستند. به عنوان مثال، اگر یک فایل اجرایی با نام مشکوک در یک دایرکتوری موقت (مانند <code>C:\Users\User\AppData\Local\Temp</code>) در BAM ظاهر شود، این می‌تواند نشانه‌ای از یک بدافزار باشد. ابزارهایی مانند Registry Explorer و Eric Zimmerman's RECmd می‌توانند داده‌های BAM/DAM را تجزیه و تحلیل کنند.</p>

<h3>Application Compatibility Cache (ShimCache)</h3>

<p><b>ShimCache</b>، که به عنوان Application Compatibility Cache نیز شناخته می‌شود، بخشی از چارچوب AppCompat ویندوز است که برای حفظ سازگاری برنامه‌های قدیمی‌تر با نسخه‌های جدیدتر ویندوز طراحی شده است. ShimCache metadata مربوط به فایل‌های اجرایی را ذخیره می‌کند تا تعیین کند آیا یک "shim" (یک لایه سازگاری) برای اجرای برنامه مورد نیاز است یا خیر.</p>
<p>ShimCache در رجیستری در <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\AppCompatCache</code> (در ویندوز Vista و بالاتر) یا <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\AppCompatibility</code> (در ویندوز XP و 2003) ذخیره می‌شود. داده‌ها به صورت باینری ذخیره می‌شوند و نیاز به ابزارهای تخصصی برای تجزیه و تحلیل دارند.</p>
<p>ShimCache اطلاعاتی مانند مسیر کامل فایل و آخرین زمان ویرایش فایل (Last Modified Time) را ذخیره می‌کند. نکته مهم این است که ShimCache زمان اجرای دقیق را ثبت نمی‌کند، بلکه زمان آخرین ویرایش فایل را ثبت می‌کند. همچنین، در ویندوز XP و 2003، یک فیلد Execution Flag وجود داشت که نشان می‌داد آیا فایل اجرا شده است یا خیر، اما این فیلد در نسخه‌های بعدی ویندوز حذف شده است.</p>
<p>یکی از نکات بسیار مهم که در پوستر اصلی به آن اشاره نشده بود، این است که ورودی‌های ShimCache زمانی که یک فایل اجرایی اجرا می‌شود یا بارگذاری می‌شود به cache اضافه می‌شوند، اما این ورودی‌ها تنها در زمان shutdown یا reboot سیستم به رجیستری نوشته می‌شوند. بنابراین، اگر یک سیستم به طور ناگهانی خاموش شود (مانند قطع برق)، ورودی‌های ShimCache که پس از آخرین reboot اضافه شده‌اند، از دست خواهند رفت.</p>
<p>ShimCache می‌تواند لیستی از برنامه‌هایی که اخیراً در سیستم اجرا یا بارگذاری شده‌اند را فراهم کند. اگرچه زمان دقیق اجرا را ثبت نمی‌کند، اما وجود یک برنامه در ShimCache نشان‌دهنده حضور آن در سیستم است. ShimCache می‌تواند با سایر آرتیفکت‌ها مانند Prefetch و AmCache ترکیب شود تا یک timeline کامل‌تر ایجاد شود. همچنین، مقایسه Last Modified Time در ShimCache با Last Modified Time واقعی فایل در سیستم فایل می‌تواند نشان دهد که آیا timestamp فایل دستکاری شده است یا خیر (یک تکنیک رایج برای مهاجمان به نام Timestomping).</p>
<p>ابزارهایی مانند Eric Zimmerman's AppCompatCacheParser و Mandiant's ShimCacheParser می‌توانند داده‌های ShimCache را تجزیه و تحلیل کنند. تحلیلگران باید به ویژه به فایل‌های اجرایی در مکان‌های غیرمعمول (مانند دایرکتوری‌های موقت، دایرکتوری‌های کاربر یا ریشه درایوها) توجه کنند.</p>

<h3>Application Activity Cache (AmCache)</h3>

<p><b>AmCache</b> یک آرتیفکت قدرتمند در ویندوز است که بخشی از چارچوب Application Compatibility ویندوز می‌باشد. AmCache برای اولین بار در ویندوز 7 معرفی شد اما به طور کامل در ویندوز 8 و نسخه‌های بالاتر پیاده‌سازی شد. AmCache metadata مفصلی در مورد فایل‌های اجرایی و DLL هایی که با سیستم تعامل داشته‌اند را ثبت می‌کند.</p>
<p>AmCache در یک فایل رجیستری جداگانه به نام <code>Amcache.hve</code> ذخیره می‌شود که در <code>C:\Windows\AppCompat\Programs\Amcache.hve</code> قرار دارد. این فایل می‌تواند با ابزارهای تجزیه و تحلیل رجیستری مانند Registry Explorer یا ابزارهای تخصصی مانند Eric Zimmerman's AmcacheParser تجزیه و تحلیل شود.</p>
<p>AmCache اطلاعات بسیار مفصلی را ثبت می‌کند، از جمله مسیر کامل فایل، هش SHA1 فایل، اندازه فایل، زمان اولین اجرا (First Execution Time)، زمان حذف (Deletion Time)، نام ناشر (Publisher)، نسخه فایل (File Version) و بسیاری اطلاعات دیگر. یکی از مهم‌ترین ویژگی‌های AmCache، ثبت هش SHA1 فایل است که به تحلیلگران اجازه می‌دهد تا فایل را با پایگاه‌های داده بدافزار (مانند VirusTotal) مطابقت دهند و ماهیت آن را شناسایی کنند.</p>
<p>یکی از نکات مهم که در پوستر اصلی به آن اشاره نشده بود، این است که AmCache نه تنها فایل‌های اجرایی (<code>.exe</code>) را ثبت می‌کند، بلکه DLL ها، درایورها (<code>.sys</code>)، فونت‌ها و حتی برخی فایل‌های دیگر را نیز ثبت می‌کند. این اطلاعات می‌توانند برای شناسایی DLL های مخرب که توسط بدافزار بارگذاری شده‌اند، بسیار مفید باشند.</p>
<p>AmCache همچنین اطلاعاتی در مورد برنامه‌های نصب شده (Installed Applications) ثبت می‌کند که می‌تواند برای شناسایی نرم‌افزارهای غیرمجاز یا مشکوک استفاده شود. علاوه بر این، AmCache اطلاعاتی در مورد درایورها (Device Drivers) و دستگاه‌های متصل (Connected Devices) نیز ثبت می‌کند که می‌تواند برای ردیابی دستگاه‌های USB یا سایر دستگاه‌های خارجی مفید باشد.</p>
<p>تحلیلگران باید به ویژه به فایل‌هایی که هش SHA1 آن‌ها با هش‌های شناخته شده بدافزار مطابقت دارند، یا فایل‌هایی که از مکان‌های غیرمعمول اجرا شده‌اند، توجه کنند. همچنین، مقایسه timestamp های AmCache با timestamp های سایر آرتیفکت‌ها می‌تواند به ایجاد یک timeline دقیق کمک کند.</p>

<h3>Prefetch</h3>

<p><b>Prefetch</b> یک مکانیزم بهینه‌سازی عملکرد در ویندوز است که برای افزایش سرعت اجرای برنامه‌ها طراحی شده است. زمانی که یک برنامه اجرا می‌شود، ویندوز فایل‌ها و DLL هایی که توسط برنامه در 10 ثانیه اول اجرا درخواست می‌شوند را ثبت می‌کند و این اطلاعات را در یک فایل Prefetch ذخیره می‌کند. در دفعات بعدی اجرای برنامه، ویندوز از این اطلاعات برای پیش‌بارگذاری (Preload) این فایل‌ها به حافظه استفاده می‌کند تا زمان راه‌اندازی برنامه کاهش یابد.</p>
<p>فایل‌های Prefetch در <code>C:\Windows\Prefetch</code> ذخیره می‌شوند و با فرمت <code>[ExecutableName]-[Hash].pf</code> نام‌گذاری می‌شوند، جایی که Hash یک هش 8 کاراکتری از مسیر اجرایی و آرگومان‌های خط فرمان است. به عنوان مثال، <code>CALC.EXE-A1B2C3D4.pf</code>.</p>
<p>هر فایل Prefetch اطلاعات بسیار مفصلی را ثبت می‌کند، از جمله نام برنامه، تعداد دفعات اجرا (Run Count)، آخرین زمان اجرا (Last Run Time)، و در ویندوز 8 و بالاتر، تا 8 آخرین زمان اجرا. همچنین، فایل Prefetch لیستی از تمامی فایل‌ها و DLL هایی که توسط برنامه در 10 ثانیه اول اجرا بارگذاری شده‌اند را ثبت می‌کند. این اطلاعات می‌توانند برای تحلیل رفتار برنامه و شناسایی وابستگی‌های آن بسیار مفید باشند.</p>
<p>یکی از نکات مهم که در پوستر اصلی به آن اشاره نشده بود، این است که Prefetch به طور پیش‌فرض تنها در ویندوز Client (مانند ویندوز 10 و 11) فعال است و در ویندوز Server به طور پیش‌فرض غیرفعال است (اگرچه می‌تواند به صورت دستی فعال شود). همچنین، تعداد فایل‌های Prefetch محدود است: در ویندوز XP تا Vista حداکثر 128 فایل و در ویندوز 7 و بالاتر حداکثر 1024 فایل. زمانی که این حد به حداکثر برسد، قدیمی‌ترین فایل‌ها حذف می‌شوند.</p>
<p>Prefetch برای تحلیل بدافزار بسیار ارزشمند است. به عنوان مثال، اگر یک بدافزار DLL های مخرب یا فایل‌های پیکربندی خاصی را بارگذاری کند، این اطلاعات در فایل Prefetch ثبت می‌شوند. همچنین، Prefetch می‌تواند نشان دهد که یک برنامه از چه مسیری اجرا شده است، حتی اگر فایل اجرایی حذف شده باشد. علاوه بر این، تحلیل timestamp های Prefetch می‌تواند به ایجاد یک timeline دقیق از فعالیت‌های سیستم کمک کند.</p>
<p>ابزارهایی مانند Eric Zimmerman's PECmd و WinPrefetchView می‌توانند فایل‌های Prefetch را تجزیه و تحلیل کنند. تحلیلگران باید به ویژه به فایل‌های Prefetch مربوط به ابزارهای سیستمی که معمولاً توسط مهاجمان استفاده می‌شوند (مانند <code>cmd.exe</code>، <code>powershell.exe</code>، <code>psexec.exe</code>، <code>wmic.exe</code> و <code>net.exe</code>) توجه کنند، زیرا این فایل‌ها می‌توانند شواهدی از فعالیت‌های مخرب فراهم کنند.</p>

<h3>Jump Lists</h3>

<p><b>Jump Lists</b> یک ویژگی در ویندوز 7 و بالاتر هستند که به کاربران اجازه می‌دهند به سرعت به فایل‌ها و برنامه‌هایی که اخیراً استفاده کرده‌اند، دسترسی پیدا کنند. Jump Lists در نوار وظیفه (Taskbar) و منوی استارت (Start Menu) ظاهر می‌شوند و لیستی از فایل‌های اخیر یا وظایف مرتبط با یک برنامه را نمایش می‌دهند.</p>
<p>Jump Lists در دو نوع وجود دارند: Automatic Destinations (که به طور خودکار توسط ویندوز ایجاد می‌شوند) و Custom Destinations (که توسط برنامه‌ها سفارشی‌سازی می‌شوند). فایل‌های Automatic Destinations در <code>AppData\Roaming\Microsoft\Windows\Recent\AutomaticDestinations</code> ذخیره می‌شوند و با فرمت <code>[AppID]-automaticDestinations-ms</code> نام‌گذاری می‌شوند، جایی که AppID یک شناسه منحصر به فرد برای هر برنامه است. فایل‌های Custom Destinations در <code>AppData\Roaming\Microsoft\Windows\Recent\CustomDestinations</code> ذخیره می‌شوند.</p>
<p>هر فایل Jump List حاوی لیستی از فایل‌هایی است که اخیراً توسط برنامه مربوطه باز شده‌اند. این فایل‌ها به صورت LNK files (Windows Shortcut files) در داخل فایل Jump List ذخیره می‌شوند و اطلاعات مفصلی مانند مسیر فایل، اندازه فایل، timestamp های فایل (Creation، Modification، Access) و حتی اطلاعات مربوط به دستگاه‌های خارجی (اگر فایل از یک دستگاه USB باز شده باشد) را ثبت می‌کنند.</p>
<p>یکی از نکات مهم که در پوستر اصلی به آن اشاره نشده بود، این است که Jump Lists می‌توانند اطلاعات بسیار ارزشمندی در مورد فعالیت‌های کاربر فراهم کنند. به عنوان مثال، Jump List مربوط به Microsoft Word می‌تواند نشان دهد که کاربر اخیراً چه اسنادی را باز کرده است. Jump List مربوط به Windows Explorer می‌تواند نشان دهد که کاربر اخیراً به چه دایرکتوری‌هایی دسترسی داشته است. Jump List مربوط به Remote Desktop (<code>mstsc.exe</code>) می‌تواند نشان دهد که کاربر اخیراً به چه سیستم‌هایی از طریق RDP متصل شده است.</p>
<p>Jump Lists همچنین می‌توانند شواهدی از فایل‌هایی که حذف شده‌اند یا از دستگاه‌های خارجی که دیگر متصل نیستند، فراهم کنند. به عنوان مثال، اگر یک کاربر یک فایل را از یک درایو USB باز کرده و سپس درایو را جدا کرده باشد، Jump List هنوز می‌تواند اطلاعاتی در مورد آن فایل و درایو USB داشته باشد.</p>
<p>ابزارهایی مانند Eric Zimmerman's JLECmd و JumpListExplorer می‌توانند فایل‌های Jump List را تجزیه و تحلیل کنند. تحلیلگران باید به ویژه به Jump Lists مربوط به برنامه‌هایی که معمولاً توسط مهاجمان استفاده می‌شوند (مانند <code>cmd.exe</code>، <code>powershell.exe</code>، <code>mstsc.exe</code> و ابزارهای فشرده‌سازی مانند WinRAR یا 7-Zip) توجه کنند، زیرا این Jump Lists می‌توانند شواهدی از فعالیت‌های مخرب فراهم کنند.</p>

</div>
